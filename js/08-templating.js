/*
 * Свойство innerHTML
 * - чтение
 * - запись
 */

// Посмотрим как можно значительно легче делать разметку использя парсинг строк.
// Предыдущий пример гораздо сложнее, но именно его необходимо научиться делать, а этот метод значительно
// проще, в будущем мы будем работать именно с парсингом строки:

// К примеру в разметке в файле HTML у нас есть <h1 class="title">Это <span>заголовок</span></h1>, получим 
// на него ссылку:

const titleEl = document.querySelector('.title');
// если выведем в консоль:
// console.log(titleEl.textContent); // то получим его содержимое
// Есть ещё одно свойство которое называется "innerHTML"
// console.log(titleEl.innerHTML);
// На первый взгляд эти два метода одинаковые, но разница в том что они возвращают и если в наш Н1 добавить
// к примеру span, т.е. вложенный элемент. В итоге:
console.log(titleEl.textContent); // возвращает все содержимое без вложенных элементов, а 
console.log(titleEl.innerHTML); // возвращает всю вложенную разметку в виде одной строки

// innerHTML можно не только прочитать но и записать!
// В итоге используя вот такую запись, мы можем перезаписать в элемент ново содержимое:
// titleEl.innerHTML = '<a href="">Это ссылка)</a>';

// В итоге он добавляет не только текстовый контент, но и новые теги.Сам распарсит ту строку, которую мы хотим
// добавить и запишет тегами вместо нас.

// Плюс innerHTML в том, что с помощью него очень просто очистить контент тега, делаем такую простую запись и наш
// тег пустой:
// titleEl.innerHTML = '';

// Необходимо использовать innerHTML в том члучае когда нам необходимо очистить тег или записать в него что - то,
//   не изменяя старый контент

// НО если мы будем добавлять новое уже к существующему таким способом:

// titleEl.innerHTML += '<a href="">Это ссылка)</a>';

// то это будет очень сильно нагружать нашу память, т.к.такая запись сначала очищает всю разметку внутри элемента
// а затем повторно создает старую запись + добавляет новую.

// А такая запись:
// titleEl.innerHTML = '<a href="">Это ссылка)</a>';
// очищает текущий контент и записывает новое, так можно и только так.

// titleEl.innerHTML = ''; // это самый быстрый способ очистки

// Если мы хотим добавить что то новое к уже существующему контенту, нам необходимо использовать
// метод insertAdjacentHTML(), т.е. значение его добавить соседний HTML:

// Работает так: element.insertAdjacentHTML(position, string), где

// element - это элемент внутрь которого м хотим добавить доп. контент
// position - это позиция с которой мы хотим добавить новый контент
//  Значение position может быть следущее: 
//   "beforebegin" - перед elem
//   "afterbegin" - всередині elem, перед усіма дітьми
//   "beforeend" - всередині elem, після усіх дітей
//   "afterend" - після elem
// string - строку(она может включать обычный текст, новые теги которые распарсятся, либо хоть всю разметку),
//   которую мы хотим добавить



/*
 * Вставка разметки с insertAdjacentHTML()
 * http://fecore.net.ua/books/m5ph3r-javascript/module-07/dom-manipulation.html#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-insertadjacenthtml
 */

titleEl.insertAdjacentHTML(
  'beforeend',
  '<a href="" class="title__link">Это ссылка)</a>',
);
